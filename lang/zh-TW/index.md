---
title: 語意化版本命名 2.0.0
language: zh-TW
---

語意化版本命名 2.0.0
====================

摘要
----

版本格式：主版號.次版號.修訂號，版號遞增規則如下：

1. 主版號：有不相容的 API 更動時，
2. 次版號：增加了向下相容的功能時，
3. 修訂號：做了向下相容的問題修正時。

先行版號及版本編譯資訊可以加到「主版號.次版號.修訂號」的後面，作為延伸。

簡介
----

在軟體管理的領域裡有個人稱「相依性地獄」的死亡之谷，系統規模越大，加入的套件越多，你就越有可能在未來的某一天發現自己已深陷絕望之中。

在相依性高的系統中發佈新版本套件可能很快會成為惡夢。如果相依性關係過高，可能面臨版本控制被鎖死的風險（必須對每一個相依套件改版才能完成某次升級）。而如果相依性關係過於鬆散，又將無法避免版本的混亂（假設相容於未來的多個版本已超出了合理數量）。當你專案的進展因為版本相依被鎖死或版本混亂變得不夠簡便和可靠，就意味著你正處於相依性地獄之中。

作為這問題的解決方案，我提議採用一套簡單的規則和要求來約束版號如何指定及遞增。這些規則的制訂是基於（但不限於）許多封閉、開源軟體廣泛使用的慣例。要讓這套體系運作，首先你要聲明公共 API，可包括撰寫文件或給出遵循的程式碼；但無論如何，這套 API 要清楚明確。一旦確立了公共 API，就可以透過特定的版號遞增方式表達其改動情形。考慮使用這樣的版號格式：X.Y.Z（主版號.次版號.修訂號），修復問題而不影響 API 時，遞增修訂號；有向下相容的 API 新增或改動時，遞增次版號；有無法向下相容的 API 改動時，遞增主版號。

我稱這套系統為「語意化版本命名」，在這套約定下，版號及其更新方式傳達了底層程式碼在某版本與下個版本之間的改動情況。

語意化版本命名規範（SemVer）
----------------------------

本文件中的關鍵詞「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」應按 [RFC 2119](https://tools.ietf.org/html/rfc2119) 的敘述解讀。（譯註：為保持文句通順，以下按整體行文翻譯，並附上對應的原文關鍵詞。）

1. 使用語意化版本命名的軟體必須（MUST）定義公共 API。該 API 可以在程式碼中定義或嚴謹地寫在文件內。無論何種形式都宜（SHOULD）力求精準詳細。

2. 標準的版號必須（MUST）採用 X.Y.Z 的格式，其中 X、Y、Z 為非負整數，且不得（MUST NOT）在數字前補零。X 是主版號、Y 是次版號、而 Z 為修訂號。每個元素必須（MUST）按數值遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。

3. 標記版號的軟體發行後，不得（MUST NOT）改變該版本軟體的內容。任何修改都必須（MUST）以新版本發行。

4. 主版號為零（0.y.z）的軟體處於開發初始階段，一切都可以（MAY）隨時改變。其公共 API 不宜（SHOULD NOT）視為穩定版。

5. 1.0.0 版定義公共 API，此後所有版號如何遞增都按這套公共 API 及其如何變動決定。

6. 修訂號 Z（x.y.Z `|` x > 0）必須（MUST）在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確軟體行為做的內在修改。

7. 次版號 Y（x.Y.z `|` x > 0）必須（MUST）在引進向下相容的公共 API 新功能時遞增。有標記公共 API 功能為棄用時也必須（MUST）遞增。還可以（MAY）在內部程式有大量新功能或改進時遞增。其中可以（MAY）包括修訂級別的改變。每當次版號遞增時，修訂號必須（MUST）歸零。

8. 主版號 X（X.y.z `|` X > 0）必須（MUST）在公共 API 引進了不相容的修改時遞增。其中可以（MAY）包括次版號及修訂號級別的改變。每當主版號遞增時，次版號和修訂號必須（MUST）歸零。

9. 先行版號可以（MAY）標註在修訂號之後，先加上一個連接號再加上一串以句點分隔的標識符號。標識符號必須（MUST）由 ASCII 英數字和連接號組成 [0-9A-Za-z-]，且不得（MUST NOT）為空。數值型標識符號不得（MUST NOT）在前方補零。先行版的優先級低於相應的標準版本。先行版表示該版本不穩定且可能無法滿足相應標準版本意圖達到的相容需求。例如：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.--。

10. 版本編譯資訊可以（MAY）標註在修訂號或先行版號之後，先加上一個加號再加上一串以句點分隔的標識符號。標識符號必須（MUST）由 ASCII 英數字和連接號組成 [0-9A-Za-z-]，且不得（MUST NOT）為空。判斷版本優先層級時必須（MUST）忽略編譯資訊，因此只有編譯資訊有差異的兩個版本屬於相同的優先層級。例如：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3----117B344092BD。

11. 版本的優先層級指的是不同版本在排序時如何比較。

    1. 計算優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不計）。

    2. 由左到右依序比較每個標識符號，以第一個有差異的值決定優先層級。比較方式為：主版號、次版號及修訂號按數值比較。

       例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。

    3. 當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。

       例如：1.0.0-alpha < 1.0.0。

    4. 主版號、次版號及修訂號相同的兩個先行版號，其優先層級的決定必須（MUST）由左而右比較以句點分隔的每個標識符號，直到找到有差異的值。比較方式如下：

       1. 標識符號只有數字時，按數值高低比較。

       2. 有字母或連接號時，視為文字按 ASCII 排序比較。

       3. 數值型標識符號的優先層級比非數值型標識符號低。

       4. 前面的標識符號都相同時，欄位較多的先行版號優先層級較高。

          例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。

有效語意化版本的 Backus–Naur 範式語法
-------------------------------------
```
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"
```

為何要使用語意化版本命名？
--------------------------

這並不是新的革命性想法，其實你八成已經在做一些類似的事情了。問題在於「類似」還不夠好，如果沒有正式規範可循，版號對於相依性的管理就沒有實質意義。將上述想法命名並賦予清楚的定義，就更容易對軟體使用者傳達意圖，當這些意圖清楚了，最終就能建立有彈性（但又不致太過彈性）的相依性規範。

舉個簡單的例子就可以展示語意化版本命名如何讓相依性地獄成為過去。假設有個名為「救火車」的函式庫，它需要另一個名為「梯子」且使用了語意化版本命名的套件。救火車建立時梯子的版號為 3.1.0。由於救火車使用了版本 3.1.0 開始引進的功能，你可以放心指定相依的梯子版號為大於或等於 3.1.0 且小於 4.0.0。這樣一來，當梯子發佈了版本 3.1.1 和 3.2.0 時，你就知道它們與原相依軟體相容且可以發行到套件管理系統。

身為負責任的開發者，你一定會想驗證每次套件升級後的運作與其說明一致。現實世界混亂不堪，除了提高警覺外我們能做的不多。你能做的是用語意化版本命名這套理智的方案發行與升級套件，如此就不必連帶處理相依套件的版本更新，省下時間與麻煩。

如果認同，請開始使用語意化版本命名，只要聲明你的程式使用它並且遵循這些規則就可以了。請在 README 文件留下此頁連結，讓別人也知道這些規則並從中受益。

常見問題
--------

### 在 0.y.z 的初始開發階段，我該如何進行版本控制？

最簡單的做法是以 0.1.0 作為你的初始化開發版本，並在後續的每次發行時遞增次版號。

### 如何判斷發佈 1.0.0 版本的時機？

如果你的軟體已經在正式環境使用，應該算 1.0.0 版了。如果已經有使用者依賴的穩定 API，應該算 1.0.0 版。如果你正在擔心許多向下相容的問題，也應該算是 1.0.0 版了。

### 這不會阻礙快速開發和迭代嗎？

主版號為零就是為了做快速開發。如果你天天改變 API，你要嘛處在 0.y.z 階段，要嘛是在下個主版本的獨立開發分支上。

### 若只是一點點不向下相容的公共 API 改變都要增加主版號，豈不是很快就達到 42.0.0 版？

就軟體開發而言，這是責任感和前瞻性的問題。不相容的改變不應輕易加入到有許多相依性程式碼的軟體中。升級所付出的代價可能很巨大。要求遞增主版號發行不相容的改版，意味著你必須為這些改變所帶來的影響深思熟慮，並且評估所涉及的成本及效益。

### 為整個公共 API 寫文件太費事了！

為供他人使用的軟體編寫適當文件，是你作為一名專業開發者應盡的職責。保持專案高效一個非常重要的部份是掌控軟體的複雜度，如果沒有人知道如何使用你的軟體或不知道哪些函數的呼叫是可靠的，要掌控複雜度會很困難。長遠來看，使用語意化版本命名並堅持定義明確的公共 API，可以讓每個人每件事運作順暢。

### 萬一不小心把一個不相容的改版當成了次版號發行了該怎麼辦？

一旦發現自己破壞了語意化版本命名的規範，就要修正這個問題，請發佈新的次版號更正問題並恢復向下相容。即使是這種情況，修改已發行的版本也是不能接受的。如果可行，請把這個有問題的版本記錄在文件中，並且告知使用者，讓他們能夠注意到有問題的版本。

### 如果我更新了自己的相依性但沒有改變公共 API 該怎麼辦？

由於不影響公共 API，可以當做是相容的。若某個軟體和你的套件相依同樣的東西，它也會有自己的相依性規範，作者也會告知可能的衝突。改版屬於修訂或次版級別，取決於你更新相依性是為了修復問題或是加入新功能，後者通常會附帶更多程式碼，那就顯然該遞增次版號。

### 如果我變更了公共 API 但無意中未遵循版號的改動怎麼辦呢？（意即，發佈修訂版卻誤加入了重大不相容的改變）

請自行做最佳判斷。如果你有一大批使用者會因改回公共 API 大受影響，最好發佈新的主版本，即使嚴格來說這只是修訂版的等級。記住，語意化版本命名就是為了用版號的改變傳達意義。若這些改變對你的使用者很重要，就用版號讓他們知道。

### 我該如何處理即將棄用的功能？

棄用現存的功能是軟體開發中的家常便飯，也通常是向前發展所必須的。當你棄用部份公共 API 時，你應該做兩件事：（1）更新你的文件讓使用者知道這個改變，（2）在適當的時機將棄用的功能透過新的次版號發佈。在新的主版本完全移除棄用功能前，至少要有一個次版本包含這個棄用資訊，讓使用者能平順地轉移到新版 API。

### 語意化版本對於版本的字串長度是否有限制呢？

沒有，但請自行做適當判斷。舉例來說，長達 255 個字元的版本號恐怕太誇張了。再者，有些系統可能會限制字串長度。

### "v1.2.3" 是語意化版本嗎？

不，"v1.2.3" 不是語意化版本。然而在語意化版本前加上 "v" 表示其為版本號是很常見的做法（就英文而言）。用 "v" 表示 "version" 的縮寫是版本控制的常見做法。例如：`git tag v1.2.3 -m "Release version 1.2.3"`，此例 "v1.2.3" 是標籤名稱，而語意化版本是 "1.2.3"。

### 有建議用於檢查語意化版本的正規表示式（RegEx）嗎？

有兩種。一種用命名群組，須在支援的系統上使用（PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R]、Python、以及 Go）。

參見：<https://regex101.com/r/Ly7O1x/3/>

```
^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

另一種使用擷取群組編號（組1 = 主版號，組2 = 次版號，組3 = 修訂號，組4 = 先行版號，組5 = 編譯資訊），與 ECMA Script (JavaScript)、PCRE (Perl Compatible Regular Expressions, i.e. Perl, PHP and R)、Python、以及 Go 相容。

參見：<https://regex101.com/r/vkijKf/1/>

```
^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

關於
----

語意化版本命名的規範最初是由 Gravatars 創辦者兼 GitHub 共同創辦者 [Tom Preston-Werner](https://tom.preston-werner.com) 建立。

如有任何建議，請[到 GitHub 上提案](https://github.com/semver/semver/issues)。

授權
----

[創用 CC 姓名標示 3.0 授權條款](https://creativecommons.org/licenses/by/3.0/)
